// Generated by CoffeeScript 1.6.3
var Player, R, RobotPlayer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

R = Config.R;

Player = (function(_super) {
  __extends(Player, _super);

  function Player(width, height, _map) {
    this._map = _map;
    Player.__super__.constructor.call(this, width, height);
    Object.defineProperties(this, this.properties);
    this.index = new Point();
    this.position = this._map.startElement;
    this.direction = Direction.UP;
  }

  Player.prototype.properties = {
    position: {
      get: function() {
        return null;
      },
      set: function(e) {
        var point;
        point = this._map.toPoint(e);
        this.x = point.x;
        this.y = point.y;
        this.index.x = e.index.x;
        return this.index.y = e.index.y;
      }
    },
    direction: {
      get: function() {
        return this._direction;
      },
      set: function(direction) {
        this._direction = direction;
        switch (direction) {
          case Direction.UP:
            return this.frame = 3;
          case Direction.RIGHT:
            return this.frame = 2;
          case Direction.DOWN:
            return this.frame = 0;
          case Direction.LEFT:
            return this.frame = 1;
        }
      }
    }
  };

  Player.prototype.move = function() {
    var e, pos;
    pos = this.index.add(this.direction);
    e = this._map.getElement(pos.x, pos.y);
    if (e !== false && !e.isImpassable()) {
      this.position = e;
      if (this._isGoal(e)) {
        this.dispatchEvent(new MazeEvent('goal'));
      }
    }
    return this.dispatchEvent(new MazeEvent('move'));
  };

  Player.prototype.turnLeft = function() {
    this.direction = Direction.prev(this.direction);
    return this.dispatchEvent(new MazeEvent('turnLeft'));
  };

  Player.prototype.turnRight = function() {
    this.direction = Direction.next(this.direction);
    return this.dispatchEvent(new MazeEvent('turnRight'));
  };

  Player.prototype.isThrough = function(direction) {
    var d, e, pos;
    switch (direction) {
      case Direction.LEFT:
        d = Direction.prev(this.direction);
        break;
      case Direction.RIGHT:
        d = Direction.next(this.direction);
        break;
      default:
        d = this.direction;
    }
    pos = this.index.add(d);
    e = this._map.getElement(pos.x, pos.y);
    return e !== false && e.isImpassable() === 0;
  };

  Player.prototype._isStart = function(e) {
    return (e != null) && e === this._map.startElement;
  };

  Player.prototype._isGoal = function(e) {
    return (e != null) && e === this._map.goalElement;
  };

  return Player;

})(Sprite);

RobotPlayer = (function(_super) {
  __extends(RobotPlayer, _super);

  RobotPlayer.WIDTH = 48;

  RobotPlayer.HEIGHT = 48;

  function RobotPlayer(map) {
    RobotPlayer.__super__.constructor.call(this, RobotPlayer.WIDTH, RobotPlayer.HEIGHT, map);
    this.image = Game.instance.assets[R.CHAR.CHAR1];
  }

  return RobotPlayer;

})(Player);
