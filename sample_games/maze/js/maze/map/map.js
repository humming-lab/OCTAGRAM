// Generated by CoffeeScript 1.6.3
var MazeMap, R,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

R = Config.R;

MazeMap = (function(_super) {
  __extends(MazeMap, _super);

  MazeMap.UNIT_SIZE = 48;

  MazeMap.prototype.properties = {
    startElement: {
      get: function() {
        return this._startElement;
      }
    },
    goalElement: {
      get: function() {
        return this._goalElement;
      }
    }
  };

  function MazeMap(matrix) {
    var collisionData, collisionLine, element, elementLine, id, x, y, _i, _j, _ref, _ref1;
    this.matrix = matrix;
    MazeMap.__super__.constructor.call(this, MazeMap.UNIT_SIZE, MazeMap.UNIT_SIZE);
    this.image = Game.instance.assets[R.MAP.SRC];
    collisionData = [];
    this.elementData = [];
    for (y = _i = 0, _ref = matrix.length; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      collisionLine = [];
      elementLine = [];
      for (x = _j = 0, _ref1 = matrix[y].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        id = matrix[y][x];
        element = ElementFactory.create(id, x, y);
        collisionLine.push(element.isImpassable());
        elementLine.push(element);
        if (element instanceof StartElement) {
          this._startElement = element;
        } else if (element instanceof GoalElement) {
          this._goalElement = element;
        }
      }
      collisionData.push(collisionLine);
      this.elementData.push(elementLine);
    }
    this.loadData(matrix);
    this.collisionData = collisionData;
    Object.defineProperties(this, this.properties);
  }

  MazeMap.prototype.getElement = function(x, y) {
    if ((0 <= x && x < this.elementData[0].length) && (0 <= y && y < this.elementData.length)) {
      return this.elementData[y][x];
    } else {
      return false;
    }
  };

  MazeMap.prototype.toPoint = function(e) {
    return new Point(this.x + this.tileWidth * e.index.x, this.x + this.tileHeight * e.index.y);
  };

  return MazeMap;

})(Map);
