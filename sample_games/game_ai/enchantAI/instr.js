// Generated by CoffeeScript 1.6.3
var AbstractMoveInstruction, HpBranchInstruction, InstrCommon, MoveInstruction, PickupInstruction, RandomMoveInstruction, RobotDirect, RobotInstruction, ScanInstructon, ShotInstruction, TipInfo, TurnScanInstruction,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

RobotInstruction = (function() {
  function RobotInstruction() {}

  RobotInstruction.MOVE = "move";

  RobotInstruction.TURN_SCAN = "turnscan";

  RobotInstruction.SHOT = "shot";

  RobotInstruction.PICKUP = "pickup";

  return RobotInstruction;

})();

RobotDirect = (function() {
  function RobotDirect(value, frame) {
    this.value = value;
    this.frame = frame;
  }

  return RobotDirect;

})();

InstrCommon = (function() {
  var directs, frame;

  function InstrCommon() {}

  directs = [Direct.RIGHT, Direct.RIGHT | Direct.DOWN, Direct.LEFT | Direct.DOWN, Direct.LEFT, Direct.LEFT | Direct.UP, Direct.RIGHT | Direct.UP];

  frame = [0, 5, 7, 2, 6, 4];

  InstrCommon.getRobotDirect = function(i) {
    return new RobotDirect(directs[i], frame[i]);
  };

  InstrCommon.getDirectSize = function() {
    return directs.length;
  };

  InstrCommon.getDirectIndex = function(direct) {
    return directs.indexOf(direct);
  };

  return InstrCommon;

})();

AbstractMoveInstruction = (function(_super) {
  __extends(AbstractMoveInstruction, _super);

  function AbstractMoveInstruction() {
    AbstractMoveInstruction.__super__.constructor.apply(this, arguments);
  }

  AbstractMoveInstruction.prototype._move = function(plate) {
    var pos, ret,
      _this = this;
    ret = false;
    this.robot.prevPlate = this.robot.currentPlate;
    if ((plate != null) && plate.lock === false) {
      pos = plate.getAbsolutePos();
      this.robot.tl.moveTo(pos.x, pos.y, PlayerRobot.UPDATE_FRAME).then(function() {
        return _this.onComplete();
      });
      this.robot.currentPlate = plate;
      ret = new Point(plate.ix, plate.iy);
    } else {
      ret = false;
    }
    return ret;
  };

  AbstractMoveInstruction.prototype.onComplete = function() {
    this.robot.onAnimateComplete();
    return AbstractMoveInstruction.__super__.onComplete.apply(this, arguments);
  };

  return AbstractMoveInstruction;

})(ActionInstruction);

TipInfo = (function() {
  function TipInfo(description) {
    this.description = description;
    this.params = {};
    this.labels = {};
  }

  TipInfo.prototype.addParameter = function(id, column, labels, value) {
    var param;
    param = {
      column: column,
      labels: labels
    };
    this.labels[id] = param.labels[value];
    return this.params[id] = param;
  };

  TipInfo.prototype.changeLabel = function(id, value) {
    return this.labels[id] = this.params[id].labels[value];
  };

  TipInfo.prototype.getLabel = function(id) {
    return this.labels[id];
  };

  TipInfo.prototype.getDescription = function() {
    var k, v, values;
    values = (function() {
      var _ref, _results;
      _ref = this.labels;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v);
      }
      return _results;
    }).call(this);
    return this.description(values);
  };

  return TipInfo;

})();

/*
  Random Move
*/


RandomMoveInstruction = (function(_super) {
  __extends(RandomMoveInstruction, _super);

  function RandomMoveInstruction(robot) {
    this.robot = robot;
    RandomMoveInstruction.__super__.constructor.apply(this, arguments);
    this.setAsynchronous(true);
    this.icon = new Icon(Game.instance.assets[R.TIP.ARROW], 32, 32);
  }

  RandomMoveInstruction.prototype.action = function() {
    var direct, plate, rand, ret;
    ret = true;
    rand = Random.nextInt() % InstrCommon.getDirectSize();
    direct = InstrCommon.getRobotDirect(rand);
    this.robot.frame = direct.frame;
    plate = this.robot.map.getTargetPoision(this.robot.currentPlate, direct.value);
    ret = this._move(plate);
    this.setAsynchronous(ret !== false);
    return this.robot.onCmdComplete(RobotInstruction.MOVE, ret);
  };

  RandomMoveInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new RandomMoveInstruction(this.robot));
    return obj;
  };

  RandomMoveInstruction.prototype.mkDescription = function() {
    return "ランダムに移動します";
  };

  RandomMoveInstruction.prototype.getIcon = function() {
    this.icon.frame = 0;
    return this.icon;
  };

  return RandomMoveInstruction;

})(AbstractMoveInstruction);

/*
  Move
*/


MoveInstruction = (function(_super) {
  __extends(MoveInstruction, _super);

  function MoveInstruction(robot) {
    var column, labels;
    this.robot = robot;
    MoveInstruction.__super__.constructor.apply(this, arguments);
    this.setAsynchronous(true);
    column = "移動方向";
    labels = ["右", "右下", "左下", "左", "左上", "右上"];
    this.directParam = new TipParameter(column, 0, 0, 5, 1);
    this.directParam.id = "direct";
    this.addParameter(this.directParam);
    this.tipInfo = new TipInfo(function(labels) {
      return "" + labels[0] + "に1マス移動します";
    });
    this.tipInfo.addParameter(this.directParam.id, column, labels, 0);
    this.icon = new Icon(Game.instance.assets[R.TIP.ARROW], 32, 32);
  }

  MoveInstruction.prototype.action = function() {
    var direct, plate, ret;
    ret = true;
    direct = InstrCommon.getRobotDirect(this.directParam.value);
    this.robot.frame = direct.frame;
    plate = this.robot.map.getTargetPoision(this.robot.currentPlate, direct.value);
    ret = this._move(plate);
    this.setAsynchronous(ret !== false);
    return this.robot.onCmdComplete(RobotInstruction.MOVE, ret);
  };

  MoveInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new MoveInstruction(this.robot));
    obj.directParam.value = this.directParam.value;
    return obj;
  };

  MoveInstruction.prototype.onParameterChanged = function(parameter) {
    if (parameter.id === this.directParam.id) {
      this.directParam = parameter;
    }
    return this.tipInfo.changeLabel(parameter.id, parameter.value);
  };

  MoveInstruction.prototype.mkDescription = function() {
    return this.tipInfo.getDescription();
  };

  MoveInstruction.prototype.mkLabel = function(parameter) {
    return this.tipInfo.getLabel(parameter.id);
  };

  MoveInstruction.prototype.getIcon = function() {
    this.icon.frame = this.directParam.value;
    return this.icon;
  };

  return MoveInstruction;

})(AbstractMoveInstruction);

/*
 Turn Scan
*/


TurnScanInstruction = (function(_super) {
  __extends(TurnScanInstruction, _super);

  function TurnScanInstruction(robot, opponent) {
    var column, labels;
    this.robot = robot;
    this.opponent = opponent;
    this._turn = __bind(this._turn, this);
    TurnScanInstruction.__super__.constructor.apply(this, arguments);
    this.setAsynchronous(true);
    this.tipInfo = new TipInfo(function(labels) {
      return "" + labels[0] + "に" + labels[1] + "回ターンします。<br>その途中に所持している弾丸の射程圏内に入っていれば、<br>青い矢印に進む。そうでなければ赤い矢印に進む。<br>(消費フレーム 1回転当たり5フレーム)      ";
    });
    column = "回転方向";
    labels = ["時計回り", "反時計回り"];
    this.rotateParam = new TipParameter(column, 0, 0, 1, 1);
    this.rotateParam.id = "rotate";
    this.addParameter(this.rotateParam);
    this.tipInfo.addParameter(this.rotateParam.id, column, labels, 0);
    column = "回転回数";
    labels = [0, 1, 2, 3, 4, 5, 6];
    this.lengthParam = new TipParameter(column, 0, 0, 6, 1);
    this.lengthParam.id = "length";
    this.addParameter(this.lengthParam);
    this.tipInfo.addParameter(this.lengthParam.id, column, labels, 0);
    this.icon = new Icon(Game.instance.assets[R.TIP.SEARCH_ENEMY], 32, 32);
  }

  TurnScanInstruction.prototype._turn = function(directIndex, i, count) {
    var bullet, direct, k, v, _ref;
    if (i < count) {
      direct = InstrCommon.getRobotDirect(directIndex);
      this.robot.frame = direct.frame;
      _ref = this.robot.bulletQueue;
      for (k in _ref) {
        v = _ref[k];
        if (v.size() > 0) {
          bullet = v.index(0);
          if (bullet.withinRange(this.robot, this.opponent, direct.value)) {
            Debug.log("find out opponent");
            this.onComplete(true);
            return;
          }
        }
      }
      return setTimeout(this._turn, (1000 * 15) / 30, (directIndex + 1) % InstrCommon.getDirectSize(), i + 1, count);
    } else {
      return this.onComplete(false);
    }
  };

  TurnScanInstruction.prototype.action = function() {
    var count, directIndex;
    count = this.lengthParam.value + 1;
    console.log(count);
    directIndex = InstrCommon.getDirectIndex(this.robot.getDirect());
    return setTimeout(this._turn, (1000 * 15) / 30, directIndex, 0, count);
  };

  TurnScanInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new TurnScanInstruction(this.robot, this.opponent));
    obj.rotateParam.value = this.rotateParam.value;
    obj.lengthParam.value = this.lengthParam.value;
    return obj;
  };

  TurnScanInstruction.prototype.onParameterChanged = function(parameter) {
    if (parameter.id === this.rotateParam.id) {
      this.rotateParam = parameter;
    } else if (parameter.id === this.lengthParam.id) {
      this.lengthParam = parameter;
    }
    return this.tipInfo.changeLabel(parameter.id, parameter.value);
  };

  TurnScanInstruction.prototype.mkDescription = function() {
    return this.tipInfo.getDescription();
  };

  TurnScanInstruction.prototype.mkLabel = function(parameter) {
    return this.tipInfo.getLabel(parameter.id);
  };

  TurnScanInstruction.prototype.getIcon = function() {
    return this.icon;
  };

  return TurnScanInstruction;

})(BranchInstruction);

ScanInstructon = (function(_super) {
  __extends(ScanInstructon, _super);

  function ScanInstructon(robot, opponent) {
    var column, labels;
    this.robot = robot;
    this.opponent = opponent;
    ScanInstructon.__super__.constructor.apply(this, arguments);
    this.tipInfo = new TipInfo(function(labels) {
      return "" + labels[0] + "バレットが射程圏内に入っていれば、青矢印に進む。<br>そうでなければ赤い矢印に進む";
    });
    column = "弾丸の種類";
    labels = {
      "1": "ストレート",
      "2": "ワイド",
      "3": "デュアル"
    };
    this.typeParam = new TipParameter(column, 1, 1, 3, 1);
    this.typeParam.id = "type";
    this.addParameter(this.typeParam);
    this.tipInfo.addParameter(this.typeParam.id, column, labels, 1);
    this.icon = new Icon(Game.instance.assets[R.TIP.SEARCH_ENEMY], 32, 32);
  }

  ScanInstructon.prototype.action = function() {
    var blt, bltQueue;
    switch (this.typeParam.value) {
      case BulletType.NORMAL:
        bltQueue = this.robot.bulletQueue.normal;
        break;
      case BulletType.WIDE:
        bltQueue = this.robot.bulletQueue.wide;
        break;
      case BulletType.DUAL:
        bltQueue = this.robot.bulletQueue.dual;
    }
    if ((bltQueue != null) && bltQueue.size() > 0) {
      blt = bltQueue.index(0);
      return blt.withinRange(this.robot, this.opponent, this.robot.getDirect());
    } else {
      return false;
    }
  };

  ScanInstructon.prototype.clone = function() {
    var obj;
    obj = this.copy(new ScanInstructon(this.robot, this.opponent));
    obj.typeParam.value = this.typeParam.value;
    return obj;
  };

  ScanInstructon.prototype.onParameterChanged = function(parameter) {
    this.typeParam = parameter;
    return this.tipInfo.changeLabel(parameter.id, parameter.value);
  };

  ScanInstructon.prototype.mkDescription = function() {
    return this.tipInfo.getDescription();
  };

  ScanInstructon.prototype.mkLabel = function(parameter) {
    return this.tipInfo.getLabel(parameter.id);
  };

  ScanInstructon.prototype.getIcon = function() {
    return this.icon;
  };

  return ScanInstructon;

})(BranchInstruction);

ShotInstruction = (function(_super) {
  __extends(ShotInstruction, _super);

  function ShotInstruction(robot) {
    var column, labels;
    this.robot = robot;
    ShotInstruction.__super__.constructor.apply(this, arguments);
    this.tipInfo = new TipInfo(function(labels) {
      return "" + labels[0] + "バレットを撃つ";
    });
    column = "弾丸の種類";
    labels = {
      "1": "ストレート",
      "2": "ワイド",
      "3": "デュアル"
    };
    this.typeParam = new TipParameter(column, 1, 1, 3, 1);
    this.typeParam.id = "type";
    this.addParameter(this.typeParam);
    this.tipInfo.addParameter(this.typeParam.id, column, labels, 1);
    this.icon = new Icon(Game.instance.assets[R.TIP.SHOT_BULLET], 32, 32);
    this.setAsynchronous(true);
  }

  ShotInstruction.prototype.action = function() {
    var b, bltQueue, ret, _i, _len, _ref,
      _this = this;
    ret = false;
    switch (this.typeParam.value) {
      case BulletType.NORMAL:
        bltQueue = this.robot.bulletQueue.normal;
        break;
      case BulletType.WIDE:
        bltQueue = this.robot.bulletQueue.wide;
        break;
      case BulletType.DUAL:
        bltQueue = this.robot.bulletQueue.dual;
    }
    if (!bltQueue.empty()) {
      _ref = bltQueue.dequeue();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        b.shot(this.robot.x, this.robot.y, this.robot.getDirect());
        this.robot.scene.world.bullets.push(b);
        this.robot.scene.world.insertBefore(b, this.robot);
        b.setOnDestoryEvent(function() {
          return _this.onComplete();
        });
        ret = b;
      }
    }
    this.setAsynchronous(ret !== false);
    return this.robot.onCmdComplete(RobotInstruction.SHOT, ret);
  };

  ShotInstruction.prototype.onComplete = function() {
    this.robot.onAnimateComplete();
    return ShotInstruction.__super__.onComplete.call(this);
  };

  ShotInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new ShotInstruction(this.robot));
    obj.typeParam.value = this.typeParam.value;
    return obj;
  };

  ShotInstruction.prototype.onParameterChanged = function(parameter) {
    this.typeParam = parameter;
    return this.tipInfo.changeLabel(parameter.id, parameter.value);
  };

  ShotInstruction.prototype.mkDescription = function() {
    return this.tipInfo.getDescription();
  };

  ShotInstruction.prototype.mkLabel = function(parameter) {
    return this.tipInfo.getLabel(parameter.id);
  };

  ShotInstruction.prototype.getIcon = function() {
    this.icon.frame = this.typeParam.value - 1;
    return this.icon;
  };

  return ShotInstruction;

})(ActionInstruction);

PickupInstruction = (function(_super) {
  __extends(PickupInstruction, _super);

  function PickupInstruction(robot) {
    var column, labels;
    this.robot = robot;
    PickupInstruction.__super__.constructor.apply(this, arguments);
    this.tipInfo = new TipInfo(function(labels) {
      return "" + labels[0] + "バレットを一つ溜める";
    });
    column = "弾丸の種類";
    labels = {
      "1": "ストレート",
      "2": "ワイド",
      "3": "デュアル"
    };
    this.typeParam = new TipParameter(column, 1, 1, 3, 1);
    this.typeParam.id = "type";
    this.addParameter(this.typeParam);
    this.tipInfo.addParameter(this.typeParam.id, column, labels, 1);
    this.icon = new Icon(Game.instance.assets[R.TIP.PICKUP_BULLET], 32, 32);
    this.setAsynchronous(true);
  }

  PickupInstruction.prototype.action = function() {
    var blt, bltQueue, item, itemClass, ret, type,
      _this = this;
    ret = false;
    type = this.typeParam.value;
    blt = BulletFactory.create(type, this.robot);
    switch (this.typeParam.value) {
      case BulletType.NORMAL:
        bltQueue = this.robot.bulletQueue.normal;
        itemClass = NormalBulletItem;
        break;
      case BulletType.WIDE:
        bltQueue = this.robot.bulletQueue.wide;
        itemClass = WideBulletItem;
        break;
      case BulletType.DUAL:
        bltQueue = this.robot.bulletQueue.dual;
        itemClass = DualBulletItem;
    }
    if (bltQueue != null) {
      ret = bltQueue.enqueue(blt);
    }
    if (ret !== false) {
      item = new itemClass(this.robot.x, this.robot.y);
      this.robot.scene.world.addChild(item);
      this.robot.scene.world.items.push(item);
      item.setOnCompleteEvent(function() {
        return _this.onComplete();
      });
      ret = blt;
    }
    this.setAsynchronous(ret !== false);
    return this.robot.onCmdComplete(RobotInstruction.PICKUP, ret);
  };

  PickupInstruction.prototype.onComplete = function() {
    this.robot.onAnimateComplete();
    return PickupInstruction.__super__.onComplete.call(this);
  };

  PickupInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new PickupInstruction(this.robot));
    return obj;
  };

  PickupInstruction.prototype.onParameterChanged = function(parameter) {
    this.typeParam = parameter;
    return this.tipInfo.changeLabel(parameter.id, parameter.value);
  };

  PickupInstruction.prototype.mkDescription = function() {
    return this.tipInfo.getDescription();
  };

  PickupInstruction.prototype.mkLabel = function(parameter) {
    return this.tipInfo.getLabel(parameter.id);
  };

  PickupInstruction.prototype.getIcon = function() {
    this.icon.frame = this.typeParam.value - 1;
    return this.icon;
  };

  return PickupInstruction;

})(ActionInstruction);

HpBranchInstruction = (function(_super) {
  __extends(HpBranchInstruction, _super);

  function HpBranchInstruction(robot) {
    var parameter;
    this.robot = robot;
    HpBranchInstruction.__super__.constructor.call(this);
    parameter = new TipParameter(HpStr.colnum(), 1, 1, 4, 1);
    this.icon = new Icon(Game.instance.assets[R.TIP.LIFE], 32, 32);
    this.addParameter(parameter);
  }

  HpBranchInstruction.prototype.action = function() {
    return this.hp <= this.robot.hp;
  };

  HpBranchInstruction.prototype.clone = function() {
    var obj;
    obj = this.copy(new HpBranchInstruction(this.robot));
    obj.hp = this.hp;
    return obj;
  };

  HpBranchInstruction.prototype.onParameterChanged = function(parameter) {
    return this.hp = parameter.value;
  };

  HpBranchInstruction.prototype.mkDescription = function() {
    return HpStr.description(this.hp);
  };

  HpBranchInstruction.prototype.getIcon = function() {
    this.icon.frame = this._id;
    return this.icon;
  };

  return HpBranchInstruction;

})(BranchInstruction);
